<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Keypoint Detection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: { 'custom-purple': '#5e0fe7' }
        }
      }
    }
  </script>
  <style>
    .keypoint { 
      position: absolute; 
      width: 12px; 
      height: 12px; 
      border-radius: 50%; 
      border: 2px solid white; 
      cursor: move; 
      z-index: 20;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .keypoint:hover { 
      transform: scale(1.2);
      box-shadow: 0 0 8px rgba(255,255,255,0.8);
    }
    .keypoint-label { 
      position: absolute; 
      top: -25px; 
      left: 50%; 
      transform: translateX(-50%);
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 2px 6px; 
      font-size: 10px; 
      border-radius: 3px;
      white-space: nowrap;
      pointer-events: none;
    }
    .connection-line {
      position: absolute;
      height: 2px;
      background: #10b981;
      transform-origin: left center;
      opacity: 0.7;
      z-index: 15;
      pointer-events: none;
    }
    .drawing-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      cursor: crosshair;
      z-index: 25;
    }
  </style>
</head>
<body class="bg-slate-50 font-sans text-gray-900 overflow-hidden">
  
  <!-- Header -->
  <header class="flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200">
    <div class="flex items-center gap-3">
      <svg class="w-5 h-5" viewBox="0 0 24 24">
        <path fill="#2563eb" d="M4 3h16a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/>
        <circle cx="8" cy="8" r="2.25" fill="#fff"/>
        <path fill="#93c5fd" d="M3 18l6-6 3 3 3-4 6 7v1H3z"/>
      </svg>
      <div>
        <h1 id="fileName" class="text-sm font-bold">Keypoint Detection Tool</h1>
        <div class="text-xs text-gray-500">Keypoint Detection & Drawing</div>
      </div>
    </div>
    <div class="flex gap-2">
      <button class="inline-flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-md bg-white text-gray-700 text-sm font-medium hover:bg-gray-50">
        <a href="#" onclick="window.history.back()">‚Üê Back to project</a>
      </button>
      <button id="exportBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-gray-900 text-white rounded-md text-sm font-medium hover:bg-gray-800">üíæ Export</button>
    </div>
  </header>

  <!-- Main Content -->
  <main class="grid grid-cols-1 xl:grid-cols-4 gap-4 p-4 h-screen">
    
    <!-- Left Section -->
    <section class="xl:col-span-3 bg-white border border-gray-200 rounded-xl p-4 flex flex-col items-center justify-center">
      
      <!-- Upload Area -->
      <div id="card" class="border-2 border-dashed border-gray-300 rounded-xl bg-gray-50 w-full max-w-4xl h-80 md:h-96 lg:h-[460px] flex items-center justify-center cursor-pointer transition-all duration-200 hover:border-blue-600 hover:bg-blue-50">
        <div id="stack" class="flex flex-col gap-3 items-center w-full h-full">
          <div id="hint" class="text-gray-500 text-center p-5 text-base font-medium">Click to select, or drop an image</div>
        </div>
        <input id="file" type="file" accept="image/*" class="absolute w-px h-px opacity-0 pointer-events-none" />
      </div>

      <!-- Controls -->
      <div class="flex flex-wrap gap-3 justify-center mt-4">
        <button id="drawBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors">‚úèÔ∏è Draw</button>
        <button id="clearBtn" class="bg-red-50 text-red-800 px-4 py-2 rounded-lg font-bold hover:bg-red-100 transition-colors">üóëÔ∏è Clear</button>
        <button id="undoBtn" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg font-bold hover:bg-gray-300 transition-colors opacity-50 cursor-not-allowed" disabled>‚Ü∂ Undo</button>
      </div>

    </section>

    <!-- Right Sidebar -->
    <aside class="bg-white border border-gray-200 rounded-xl p-4 overflow-y-auto">
      
      <!-- Drawing Tools -->
      <div class="mb-1">
        <h3 class="text-lg font-bold mb-3">Drawing Tools</h3>
        <div class="space-y-3">
          
          <!-- Brush Size Control -->
          <div class="border border-gray-200 rounded-lg bg-white p-3 shadow-sm">
            <div class="mb-2">
              <span class="text-sm font-medium text-gray-700">Brush Size: <span id="brushSizeValue">3</span>px</span>
            </div>
            <input type="range" id="brushSizeSlider" min="1" max="20" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            <div class="flex justify-between text-xs text-gray-500 mt-1">
              <span>1px</span>
              <span>20px</span>
            </div>
          </div>
          
          <!-- Color Palette -->
          <div class="border border-gray-200 rounded-lg bg-white p-3 shadow-sm">
            <label class="block text-sm font-semibold mb-2">Brush Color</label>
            <div class="grid grid-cols-4 gap-2">
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #ef4444" data-color="#ef4444" title="Red"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #3b82f6" data-color="#3b82f6" title="Blue"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #10b981" data-color="#10b981" title="Green"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #f59e0b" data-color="#f59e0b" title="Yellow"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #8b5cf6" data-color="#8b5cf6" title="Purple"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #ec4899" data-color="#ec4899" title="Pink"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #000000" data-color="#000000" title="Black"></button>
              <button class="color-btn w-4 h-4 rounded-full border-2 border-gray-300 hover:scale-110 transition-transform" style="background-color: #ffffff" data-color="#ffffff" title="White"></button>
            </div>
          </div>
        </div>
      </div>

      <!-- Keypoint Types -->
      <div class="mb-6">
        <h3 class="text-lg font-bold mb-3">Keypoint Types</h3>
        <div class="space-y-2">
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-red-500">Head</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Head" data-color="#ef4444">Select</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-blue-600">Shoulder</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Shoulder" data-color="#3b82f6">Select</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-green-600">Elbow</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Elbow" data-color="#10b981">Select</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-amber-500">Wrist</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Wrist" data-color="#f59e0b">Select</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-violet-600">Hip</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Hip" data-color="#8b5cf6">Select</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-purple-500">Knee</span>
            <button class="keypoint-btn border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold" data-type="Knee" data-color="#a855f7">Select</button>
          </div>
        </div>
      </div>

      <!-- Detection Controls -->
      <div>
        <h3 class="text-lg font-bold mb-3">Controls</h3>
        <div class="space-y-2">
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-green-600">Add Keypoint</span>
            <button id="modeAdd" class="border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold">Enable</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-blue-600">Connect Points</span>
            <button id="modeConnect" class="border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold">Enable</button>
          </div>
          <div class="flex items-center justify-between border border-gray-200 rounded-lg bg-white p-2 shadow-sm hover:shadow-md transition-shadow">
            <span class="font-bold text-sm text-red-500">Delete Mode</span>
            <button id="modeDelete" class="border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold">Enable</button>
          </div>
        </div>
      </div>
      
    </aside>
  </main>

<script>
// Application State
let activeImage = null;
let drawingMode = false;
let keypointMode = false;
let connectMode = false;
let deleteMode = false;
let isDrawing = false;

// Drawing state
let drawingCanvas = null;
let drawingCtx = null;
let currentBrushSize = 3;
let currentColor = '#ef4444';

// Keypoint state
let keypoints = [];
let connections = [];
let selectedKeypoints = [];
let currentKeypointType = 'Head';

// Data storage
let drawingHistory = [];
let keypointHistory = [];

// Get DOM elements
const card = document.getElementById('card');
const stack = document.getElementById('stack');
const fileInput = document.getElementById('file');
const hint = document.getElementById('hint');
const fileInfo = document.getElementById('fileInfo');
const fileName = document.getElementById('fileName');
const urlInput = document.getElementById('urlInput');

const drawBtn = document.getElementById('drawBtn');
const clearBtn = document.getElementById('clearBtn');
const undoBtn = document.getElementById('undoBtn');
const exportBtn = document.getElementById('exportBtn');

const brushSizeSlider = document.getElementById('brushSizeSlider');
const brushSizeValue = document.getElementById('brushSizeValue');

// Initialize color buttons
document.querySelectorAll('.color-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('ring-4', 'ring-blue-500'));
    btn.classList.add('ring-4', 'ring-blue-500');
    currentColor = btn.dataset.color;
    if (drawingCtx) {
      drawingCtx.strokeStyle = currentColor;
    }
  });
});

// Set default color
document.querySelector('.color-btn[data-color="#ef4444"]').classList.add('ring-4', 'ring-blue-500');

// Brush size controls
brushSizeSlider.addEventListener('input', () => {
  currentBrushSize = parseInt(brushSizeSlider.value);
  brushSizeValue.textContent = currentBrushSize;
  if (drawingCtx) {
    drawingCtx.lineWidth = currentBrushSize;
  }
});

// Keypoint type selection
document.querySelectorAll('.keypoint-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.keypoint-btn').forEach(b => {
      b.className = 'border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold';
    });
    btn.className = 'border border-blue-500 rounded-md px-2 py-1 bg-blue-50 text-xs font-semibold';
    currentKeypointType = btn.dataset.type;
  });
});

// Set default keypoint type
document.querySelector('.keypoint-btn[data-type="Head"]').click();

// Mode toggles
document.getElementById('modeAdd').addEventListener('click', (e) => {
  keypointMode = !keypointMode;
  updateModeButton(e.target, keypointMode, 'green');
  if (keypointMode) {
    connectMode = deleteMode = false;
    updateAllModeButtons();
  }
});

document.getElementById('modeConnect').addEventListener('click', (e) => {
  connectMode = !connectMode;
  updateModeButton(e.target, connectMode, 'blue');
  if (connectMode) {
    keypointMode = deleteMode = false;
    updateAllModeButtons();
  }
});

document.getElementById('modeDelete').addEventListener('click', (e) => {
  deleteMode = !deleteMode;
  updateModeButton(e.target, deleteMode, 'red');
  if (deleteMode) {
    keypointMode = connectMode = false;
    updateAllModeButtons();
  }
});

function updateModeButton(button, isActive, color) {
  if (isActive) {
    button.textContent = 'Disable';
    button.className = `border border-${color}-500 rounded-md px-2 py-1 bg-${color}-50 text-xs font-semibold text-${color}-700`;
  } else {
    button.textContent = 'Enable';
    button.className = 'border border-gray-300 rounded-md px-2 py-1 bg-white text-xs font-semibold';
  }
}

function updateAllModeButtons() {
  updateModeButton(document.getElementById('modeAdd'), keypointMode, 'green');
  updateModeButton(document.getElementById('modeConnect'), connectMode, 'blue');
  updateModeButton(document.getElementById('modeDelete'), deleteMode, 'red');
}

// Drawing functions
function createDrawingCanvas(container) {
  const existingCanvas = container.querySelector('.drawing-canvas');
  if (existingCanvas) {
    existingCanvas.remove();
  }
  
  const canvas = document.createElement('canvas');
  canvas.className = 'drawing-canvas';
  
  const img = container.querySelector('img');
  if (img) {
    const rect = img.getBoundingClientRect();
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    canvas.style.width = img.offsetWidth + 'px';
    canvas.style.height = img.offsetHeight + 'px';
  }
  
  container.appendChild(canvas);
  return canvas;
}

function getCanvasPosition(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

function startDrawing(e) {
  if (!drawingMode || !drawingCanvas) return;
  
  isDrawing = true;
  const pos = getCanvasPosition(e, drawingCanvas);
  
  drawingCtx.lineWidth = currentBrushSize;
  drawingCtx.lineCap = 'round';
  drawingCtx.lineJoin = 'round';
  drawingCtx.globalCompositeOperation = 'source-over';
  drawingCtx.strokeStyle = currentColor;
  drawingCtx.globalAlpha = 0.8;
  
  drawingCtx.beginPath();
  drawingCtx.moveTo(pos.x, pos.y);
  
  e.preventDefault();
}

function draw(e) {
  if (!isDrawing || !drawingMode) return;
  
  const pos = getCanvasPosition(e, drawingCanvas);
  drawingCtx.lineTo(pos.x, pos.y);
  drawingCtx.stroke();
  
  e.preventDefault();
}

function stopDrawing(e) {
  if (!isDrawing) return;
  
  isDrawing = false;
  saveDrawingState();
  e.preventDefault();
}

function saveDrawingState() {
  if (drawingCanvas) {
    drawingHistory.push(drawingCanvas.toDataURL());
    if (drawingHistory.length > 50) {
      drawingHistory.shift();
    }
  }
  updateUndoButton();
}

// Keypoint functions
function createKeypoint(x, y, type, color) {
  const keypoint = document.createElement('div');
  keypoint.className = 'keypoint';
  keypoint.style.left = (x - 6) + 'px';
  keypoint.style.top = (y - 6) + 'px';
  keypoint.style.backgroundColor = color;
  keypoint.dataset.type = type;
  keypoint.dataset.id = Date.now().toString();
  
  const label = document.createElement('div');
  label.className = 'keypoint-label';
  label.textContent = type;
  keypoint.appendChild(label);
  
  keypoint.addEventListener('click', (e) => {
    e.stopPropagation();
    
    if (deleteMode) {
      removeKeypoint(keypoint);
    } else if (connectMode) {
      selectKeypointForConnection(keypoint);
    }
  });
  
  // Make keypoint draggable
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  keypoint.addEventListener('mousedown', (e) => {
    if (deleteMode || connectMode) return;
    
    isDragging = true;
    const rect = activeImage.container.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left - x;
    dragOffset.y = e.clientY - rect.top - y;
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    
    const rect = activeImage.container.getBoundingClientRect();
    const newX = e.clientX - rect.left - dragOffset.x;
    const newY = e.clientY - rect.top - dragOffset.y;
    
    keypoint.style.left = (newX - 6) + 'px';
    keypoint.style.top = (newY - 6) + 'px';
    
    // Update keypoint data
    const keypointData = keypoints.find(kp => kp.id === keypoint.dataset.id);
    if (keypointData) {
      keypointData.x = newX;
      keypointData.y = newY;
    }
    
    updateConnections();
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      saveKeypointState();
    }
  });
  
  return keypoint;
}

function removeKeypoint(keypointElement) {
  const id = keypointElement.dataset.id;
  
  // Remove from keypoints array
  keypoints = keypoints.filter(kp => kp.id !== id);
  
  // Remove connections involving this keypoint
  connections = connections.filter(conn => conn.from !== id && conn.to !== id);
  
  // Remove DOM element
  keypointElement.remove();
  
  // Update connection lines
  updateConnections();
  saveKeypointState();
}

function selectKeypointForConnection(keypoint) {
  const id = keypoint.dataset.id;
  
  if (selectedKeypoints.includes(id)) {
    selectedKeypoints = selectedKeypoints.filter(kid => kid !== id);
    keypoint.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
  } else {
    selectedKeypoints.push(id);
    keypoint.style.boxShadow = '0 0 0 3px #10b981';
  }
  
  if (selectedKeypoints.length === 2) {
    createConnection(selectedKeypoints[0], selectedKeypoints[1]);
    clearSelectedKeypoints();
  }
}

function createConnection(fromId, toId) {
  const connection = { from: fromId, to: toId, id: Date.now().toString() };
  connections.push(connection);
  updateConnections();
  saveKeypointState();
}

function clearSelectedKeypoints() {
  selectedKeypoints.forEach(id => {
    const keypoint = activeImage.container.querySelector(`[data-id="${id}"]`);
    if (keypoint) {
      keypoint.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
    }
  });
  selectedKeypoints = [];
}

function updateConnections() {
  // Remove existing connection lines
  activeImage.container.querySelectorAll('.connection-line').forEach(line => line.remove());
  
  // Draw new connection lines
  connections.forEach(conn => {
    const fromKeypoint = keypoints.find(kp => kp.id === conn.from);
    const toKeypoint = keypoints.find(kp => kp.id === conn.to);
    
    if (fromKeypoint && toKeypoint) {
      const line = document.createElement('div');
      line.className = 'connection-line';
      
      const dx = toKeypoint.x - fromKeypoint.x;
      const dy = toKeypoint.y - fromKeypoint.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      line.style.left = fromKeypoint.x + 'px';
      line.style.top = fromKeypoint.y + 'px';
      line.style.width = length + 'px';
      line.style.transform = `rotate(${angle}deg)`;
      
      activeImage.container.appendChild(line);
    }
  });
}

function saveKeypointState() {
  keypointHistory.push({
    keypoints: JSON.parse(JSON.stringify(keypoints)),
    connections: JSON.parse(JSON.stringify(connections))
  });
  if (keypointHistory.length > 50) {
    keypointHistory.shift();
  }
  updateUndoButton();
}

// Image handling
function handleImageClick(e) {
  if (!activeImage || !keypointMode) return;
  
  const rect = activeImage.container.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const keypointColor = document.querySelector('.keypoint-btn.border-blue-500').dataset.color;
  const keypoint = createKeypoint(x, y, currentKeypointType, keypointColor);
  activeImage.container.appendChild(keypoint);
  
  keypoints.push({
    x: x,
    y: y,
    type: currentKeypointType,
    color: keypointColor,
    id: keypoint.dataset.id
  });
  
  saveKeypointState();
}

// Button event handlers
drawBtn.addEventListener('click', () => {
  if (!activeImage) {
    alert('Please upload an image first!');
    return;
  }
  
  drawingMode = !drawingMode;
  
  if (drawingMode) {
    drawBtn.textContent = '‚è∏Ô∏è Stop Drawing';
    drawBtn.className = 'bg-red-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-red-700 transition-colors';
    
    // Create drawing canvas
    drawingCanvas = createDrawingCanvas(activeImage.container);
    drawingCtx = drawingCanvas.getContext('2d');
    
    // Add drawing event listeners
    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseleave', stopDrawing);
    
    // Touch events for mobile
    drawingCanvas.addEventListener('touchstart', startDrawing);
    drawingCanvas.addEventListener('touchmove', draw);
    drawingCanvas.addEventListener('touchend', stopDrawing);
    
    // Disable other modes
    keypointMode = connectMode = deleteMode = false;
    updateAllModeButtons();
    
  } else {
    drawBtn.textContent = '‚úèÔ∏è Draw';
    drawBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors';
    
    // Remove drawing canvas
    if (drawingCanvas) {
      drawingCanvas.remove();
      drawingCanvas = null;
      drawingCtx = null;
    }
    drawingHistory = [];
    updateUndoButton();
  }
});

clearBtn.addEventListener('click', () => {
  if (!activeImage) {
    alert('Please upload an image first!');
    return;
  }
  
  if (confirm('Clear all drawings and keypoints?')) {
    // Clear drawing canvas
    if (drawingCanvas) {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
    
    // Clear keypoints
    activeImage.container.querySelectorAll('.keypoint').forEach(kp => kp.remove());
    activeImage.container.querySelectorAll('.connection-line').forEach(line => line.remove());
    
    keypoints = [];
    connections = [];
    selectedKeypoints = [];
    drawingHistory = [];
    keypointHistory = [];
    
    updateUndoButton();
  }
});

undoBtn.addEventListener('click', () => {
  if (!activeImage) {
    alert('Please upload an image first!');
    return;
  }
  
  if (drawingMode && drawingHistory.length > 1) {
    // Undo drawing
    drawingHistory.pop();
    const lastState = drawingHistory[drawingHistory.length - 1];
    
    if (lastState) {
      const img = new Image();
      img.onload = () => {
        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        drawingCtx.drawImage(img, 0, 0);
      };
      img.src = lastState;
    } else {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
  } else if (keypointHistory.length > 1) {
    // Undo keypoint changes
    keypointHistory.pop();
    const lastState = keypointHistory[keypointHistory.length - 1];
    
    // Clear current keypoints and connections
    activeImage.container.querySelectorAll('.keypoint').forEach(kp => kp.remove());
    activeImage.container.querySelectorAll('.connection-line').forEach(line => line.remove());
    
    // Restore previous state
    keypoints = lastState.keypoints;
    connections = lastState.connections;
    
    // Recreate keypoints
    keypoints.forEach(kpData => {
      const keypoint = createKeypoint(kpData.x, kpData.y, kpData.type, kpData.color);
      keypoint.dataset.id = kpData.id;
      activeImage.container.appendChild(keypoint);
    });
    
    // Recreate connections
    updateConnections();
  }
  
  updateUndoButton();
});

function updateUndoButton() {
  const hasDrawingHistory = drawingMode && drawingHistory.length > 1;
  const hasKeypointHistory = !drawingMode && keypointHistory.length > 1;
  const canUndo = hasDrawingHistory || hasKeypointHistory;
  
  undoBtn.disabled = !canUndo;
  undoBtn.classList.toggle('opacity-50', !canUndo);
  undoBtn.classList.toggle('cursor-not-allowed', !canUndo);
}

// Export functionality
exportBtn.addEventListener('click', () => {
  if (!activeImage) {
    alert('No image to export!');
    return;
  }
  
  const exportData = {
    timestamp: new Date().toISOString(),
    imageName: activeImage.name,
    keypoints: keypoints,
    connections: connections,
    drawingData: drawingCanvas ? drawingCanvas.toDataURL() : null
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `keypoint_detection_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  alert('Keypoint data exported successfully!');
});

// Image handling - Simplified click logic
card.addEventListener('click', (e) => {
  // Handle keypoint placement when in keypoint mode
  if (keypointMode && activeImage && activeImage.container.contains(e.target)) {
    handleImageClick(e);
    return;
  }
  
  // Always allow image upload when clicking unless actively drawing on canvas
  if (drawingMode && drawingCanvas && e.target === drawingCanvas) {
    return; // Allow drawing on canvas
  }
  
  // For any other click, trigger file input
  fileInput.click();
});

fileInput.addEventListener('change', (e) => {
  if (e.target.files && e.target.files.length) {
    loadImageFile(e.target.files[0]);
  }
});

// Drag & Drop
['dragenter', 'dragover'].forEach(eventName => {
  card.addEventListener(eventName, (e) => {
    e.preventDefault();
    card.className = 'border-2 border-dashed border-blue-600 rounded-xl bg-blue-50 w-full max-w-4xl h-80 md:h-96 lg:h-[460px] flex items-center justify-center cursor-pointer transition-all duration-200';
    if (hint) hint.textContent = 'Drop your image here';
  });
});

card.addEventListener('dragleave', (e) => {
  e.preventDefault();
  card.className = 'border-2 border-dashed border-gray-300 rounded-xl bg-gray-50 w-full max-w-4xl h-80 md:h-96 lg:h-[460px] flex items-center justify-center cursor-pointer transition-all duration-200 hover:border-blue-600 hover:bg-blue-50';
  if (hint) hint.textContent = 'Click to select, or drop an image';
});

card.addEventListener('drop', (e) => {
  e.preventDefault();
  card.className = 'border-2 border-dashed border-gray-300 rounded-xl bg-gray-50 w-full max-w-4xl h-80 md:h-96 lg:h-[460px] flex items-center justify-center cursor-pointer transition-all duration-200 hover:border-blue-600 hover:bg-blue-50';
  if (e.dataTransfer.files && e.dataTransfer.files.length) {
    loadImageFile(e.dataTransfer.files[0]);
  }
});

function loadImageFile(file) {
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file');
    return;
  }
  
  if (hint) {
    hint.textContent = 'Loading...';
    hint.className = 'text-blue-600 text-center p-5 text-base font-semibold';
  }
  
  const reader = new FileReader();
  reader.onload = (e) => createImageElement(e.target.result, file.name);
  reader.onerror = () => {
    if (hint) {
      hint.textContent = 'Failed to load image';
      hint.className = 'text-red-600 text-center p-5 text-base font-semibold';
    }
  };
  reader.readAsDataURL(file);
}

function createImageElement(src, name) {
  // Reset state
  drawingMode = false;
  keypointMode = connectMode = deleteMode = false;
  keypoints = [];
  connections = [];
  selectedKeypoints = [];
  drawingHistory = [];
  keypointHistory = [];
  
  // Reset UI
  drawBtn.textContent = '‚úèÔ∏è Draw';
  drawBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors';
  updateAllModeButtons();
  updateUndoButton();
  
  // Remove hint
  if (hint) hint.remove();
  
  // Clear existing content
  stack.innerHTML = '';
  
  // Create container
  const container = document.createElement('div');
  container.className = 'relative flex items-center justify-center w-full h-full rounded-lg overflow-hidden';
  
  // Create image
  const img = new Image();
  img.onload = () => {
    img.className = 'max-w-full max-h-full w-auto h-auto rounded-lg shadow-lg';
    container.appendChild(img);
    stack.appendChild(container);
    
    activeImage = { container, img, name, src };
    fileName.textContent = name;
    fileInfo.innerHTML = `Loaded: <b>${name}</b>`;
    
    // Initialize history
    keypointHistory = [{ keypoints: [], connections: [] }];
  };
  
  img.onerror = () => {
    stack.innerHTML = '<div class="text-red-600 text-center p-5 text-base font-semibold">Failed to load image</div>';
  };
  
  img.src = src;
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  updateUndoButton();
  updateAllModeButtons();
});
</script>

</body>
</html>
